{"version":3,"file":"index.js","sources":["../src/globals.ts","../src/general-functions.ts","../src/pseudo-methods.ts","../src/supporting-functions.ts","../src/constants.ts","../src/index.ts"],"sourcesContent":["/**\n * 2024 Native Signals <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\nexport const ND = Symbol.for(\"proxserve_node_data\"); // key for the data of a node\nexport const NID = Symbol.for(\"proxserve_node_inherited_data\"); // key for the inherited data of a node\n\n// acceptable types to be proxied\nexport const proxyTypes = {\n\tObject: true,\n\tArray: true,\n};\n\n// statuses of data-nodes\nexport enum NODE_STATUSES {\n\tactive = \"active\",\n\tstopped = \"stopped\",\n\tblocked = \"blocked\",\n\tsplicing = \"splicing\",\n}\n\n// statuses of proxies\nexport enum PROXY_STATUSES {\n\talive = \"alive\",\n\tdeleted = \"deleted\",\n\trevoked = \"revoked\",\n}\n\n// event names that can be emitted\nexport enum EVENTS {\n\tcreate = \"create\",\n\tupdate = \"update\",\n\tdelete = \"delete\",\n\tsplice = \"splice\",\n\tshift = \"shift\",\n\tunshift = \"unshift\",\n}\n","/**\n * 2024 Native Signals <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\nimport type { SomeObject, SomeArray, VariableTypes } from \"./types/globals\";\n\n/**\n * return a string representing the full type of the variable\n */\nexport function realtypeof(variable: any): VariableTypes {\n\tconst rawType = Object.prototype.toString.call(variable); //[object Object], [object Array], [object Number]...\n\treturn rawType.substring(8, rawType.length - 1) as VariableTypes;\n}\n\n/**\n * check if variable is a number or a string of a number\n * @param variable\n */\n/*export function isNumeric(variable: any): boolean {\n\tif(typeof variable === 'string' && variable === '') {\n\t\treturn false;\n\t}\n\t\n\treturn !isNaN(variable as number);\n}*/\n\n/**\n * recursively clones objects and array\n */\nconst simpleCloneSet = new WeakSet();\nexport function simpleClone(variable: any): any {\n\tconst typeofvar = realtypeof(variable);\n\n\tif (typeofvar === \"Object\") {\n\t\tconst obj = variable as SomeObject;\n\t\tsimpleCloneSet.add(obj);\n\t\tconst cloned = {};\n\t\tconst keys = Object.keys(obj);\n\t\tfor (const key of keys) {\n\t\t\tif (simpleCloneSet.has(obj[key])) {\n\t\t\t\tcloned[key] = obj[key];\n\t\t\t} else {\n\t\t\t\tcloned[key] = simpleClone(obj[key]);\n\t\t\t}\n\t\t}\n\t\treturn cloned;\n\t}\n\n\tif (typeofvar === \"Array\") {\n\t\tconst arr = variable as SomeArray;\n\t\tsimpleCloneSet.add(arr);\n\t\tconst cloned = [] as any[];\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tif (simpleCloneSet.has(arr[i])) {\n\t\t\t\tcloned[i] = arr[i];\n\t\t\t} else {\n\t\t\t\tcloned[i] = simpleClone(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn cloned;\n\t}\n\n\t// hopefully a primitive\n\tif (\n\t\ttypeofvar !== \"Undefined\" &&\n\t\ttypeofvar !== \"Null\" &&\n\t\ttypeofvar !== \"Boolean\" &&\n\t\ttypeofvar !== \"Number\" &&\n\t\ttypeofvar !== \"BigInt\" &&\n\t\ttypeofvar !== \"String\"\n\t) {\n\t\tconsole.warn(`Can't clone a variable of type ${typeofvar}`);\n\t}\n\treturn variable;\n}\n\n/**\n * splits a path to an array of properties\n * (benchmarked and is faster than regex and split())\n * @param path\n */\nexport function splitPath(path: string): Array<string | number> {\n\tif (typeof path !== \"string\" || path === \"\") {\n\t\treturn [];\n\t}\n\n\tlet i = 0;\n\tlet isBetweenBrackets = false;\n\tlet isOnlyDigits = false;\n\t//loop will skip over openning '.' or '['\n\tif (path[0] === \".\") {\n\t\ti = 1;\n\t} else if (path[0] === \"[\") {\n\t\ti = 1;\n\t\tisBetweenBrackets = true;\n\t\tisOnlyDigits = true;\n\t}\n\n\tconst resultsArr = [] as Array<string | number>;\n\tlet tmp = \"\";\n\tfor (; i < path.length; i++) {\n\t\tconst char = path[i];\n\n\t\tif (isBetweenBrackets) {\n\t\t\tif (char === \"]\") {\n\t\t\t\tif (isOnlyDigits) {\n\t\t\t\t\tresultsArr.push(Number.parseInt(tmp, 10));\n\t\t\t\t} else {\n\t\t\t\t\tresultsArr.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tisBetweenBrackets = false;\n\t\t\t\tisOnlyDigits = false;\n\t\t\t\ttmp = \"\";\n\t\t\t} else {\n\t\t\t\tif (isOnlyDigits) {\n\t\t\t\t\tconst code = char.charCodeAt(0);\n\t\t\t\t\tif (code < 48 || code > 57) {\n\t\t\t\t\t\t//less than '0' char or greater than '9' char\n\t\t\t\t\t\tisOnlyDigits = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t} else {\n\t\t\tif (char === \"[\") {\n\t\t\t\tisBetweenBrackets = true;\n\t\t\t\tisOnlyDigits = true;\n\t\t\t}\n\n\t\t\t//check if starting a new property but avoid special case of [prop][prop]\n\t\t\tif (char === \".\" || char === \"[\") {\n\t\t\t\tif (tmp !== \"\") {\n\t\t\t\t\tresultsArr.push(tmp);\n\t\t\t\t\ttmp = \"\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttmp += char;\n\t\t\t}\n\t\t}\n\t}\n\tif (tmp !== \"\") {\n\t\tresultsArr.push(tmp);\n\t}\n\treturn resultsArr;\n}\n\n/**\n * evaluate a long path and return the designated object and its referred property\n */\nexport function evalPath(\n\tobj: SomeObject,\n\tpath: string\n): {\n\tobject: SomeObject;\n\tproperty: string | number;\n\tvalue: any;\n} {\n\tif (path === \"\") {\n\t\treturn {\n\t\t\tobject: obj,\n\t\t\tproperty: \"\",\n\t\t\tvalue: obj,\n\t\t};\n\t}\n\n\tconst segments = splitPath(path);\n\tlet i: number;\n\tlet childObj = obj;\n\n\tfor (i = 0; i <= segments.length - 2; i++) {\n\t\t// iterate until one before last property because they all must exist\n\t\tchildObj = childObj[segments[i]];\n\t\tif (typeof childObj === \"undefined\") {\n\t\t\tthrow new Error(`Invalid path was given - \"${path}\"`);\n\t\t}\n\t}\n\n\treturn {\n\t\tobject: childObj,\n\t\tproperty: segments[i],\n\t\tvalue: childObj[segments[i]],\n\t};\n}\n","/**\n * 2024 Native Signals <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n// Pseudo methods are methods that aren't really on the object - not as a property nor via its prototype\n// thus they will not be retrieved via \"for..in\" and etcetera. Their property name is actually undefined, but\n// calling it will return the method via the JS proxy's \"get\" handler.\n// (i.e. someProxserve.pseudoFunction will return the pseudoFunction)\n\nimport { EVENTS, NODE_STATUSES, ND, NID } from \"./globals\";\nimport type { ListenerData, EVENT_NAMES } from \"./types/globals\";\nimport type { PseudoThis } from \"./types/proxserve-class\";\nimport type {\n\tStopFunction,\n\tBlockFunction,\n\tActivateFunction,\n\tOnFunction,\n\tOnceFunction,\n\tRemoveListenerFunction,\n\tRemoveAllListenersFunction,\n\tGetProxserveNameFunction,\n\tWhoAMI,\n\tGetOriginalTargetFunction,\n\tGetProxserveNodesFunction,\n} from \"./types/pseudo-methods\";\nimport { createNodes } from \"./supporting-functions\";\nimport { splitPath } from \"./general-functions\";\n\nexport const stop: StopFunction = function stop(this: PseudoThis) {\n\tthis.dataNode[NID].status = NODE_STATUSES.stopped;\n};\n\nexport const block: BlockFunction = function block(this: PseudoThis) {\n\tthis.dataNode[NID].status = NODE_STATUSES.blocked;\n};\n\nexport const activate: ActivateFunction = function activate(\n\tthis: PseudoThis,\n\tforce = false\n): void {\n\tif (force || this.dataNode === this.metadata.dataTree) {\n\t\t// force activation or we are on root proxy\n\t\tthis.dataNode[NID].status = NODE_STATUSES.active;\n\t} else {\n\t\tdelete this.dataNode[NID].status;\n\t}\n};\n\nexport const on: OnFunction = function on(this: PseudoThis, args) {\n\tconst { path = \"\", listener, id, deep = false, once = false } = args;\n\t// its nicer to expose `event` to the user,\n\t// but since it is semi-reserved word, we internally rename it to `events`\n\tlet { event: events } = args;\n\n\tif (events === \"change\") {\n\t\tevents = Object.keys(EVENTS) as EVENT_NAMES[]; // will listen to all events\n\t} else if (!Array.isArray(events)) {\n\t\tevents = [events];\n\t}\n\n\tfor (const event of events) {\n\t\tif (!EVENTS[event]) {\n\t\t\tconst names = Object.keys(EVENTS);\n\t\t\tthrow new Error(\n\t\t\t\t`${event} is not a valid event. valid events are ${names.join(\n\t\t\t\t\t\",\"\n\t\t\t\t)}`\n\t\t\t);\n\t\t}\n\t}\n\n\tlet dataNode = this.dataNode;\n\tconst segments = splitPath(path);\n\tfor (const property of segments) {\n\t\t// traverse down the tree\n\t\tif (!dataNode[property]) {\n\t\t\t// create data-nodes if needed (in dataNode[property]), but don't create/overwrite proxy-nodes\n\t\t\tcreateNodes(dataNode, property);\n\t\t}\n\n\t\tdataNode = dataNode[property];\n\t}\n\n\tlet listenersPool = dataNode[ND].listeners.shallow;\n\tif (deep) {\n\t\tlistenersPool = dataNode[ND].listeners.deep;\n\t}\n\n\tconst listenerObj = {\n\t\ttype: events,\n\t\tonce,\n\t\tfunc: listener,\n\t} as ListenerData;\n\n\tif (id !== undefined) {\n\t\tlistenerObj.id = id;\n\t}\n\tlistenersPool.push(listenerObj);\n};\n\nexport const once: OnceFunction = function once(this: PseudoThis, args) {\n\targs.once = true;\n\ton.call(this, args);\n};\n\nfunction removeById(\n\tlistenersArr: ListenerData[],\n\t// biome-ignore lint/complexity/noBannedTypes: <explanation>\n\tid: string | number | Function\n): void {\n\tfor (let i = listenersArr.length - 1; i >= 0; i--) {\n\t\tconst listenerObj = listenersArr[i];\n\t\tif (\n\t\t\t(id !== undefined && listenerObj.id === id) ||\n\t\t\tlistenerObj.func === id\n\t\t) {\n\t\t\tlistenersArr.splice(i, 1);\n\t\t}\n\t}\n}\n\nexport const removeListener: RemoveListenerFunction = function removeListener(\n\tthis: PseudoThis,\n\targs\n) {\n\tconst { id, path = \"\" } = args;\n\tconst fullPath = `${this.dataNode[ND].path}${path}`;\n\tlet dataNode = this.dataNode;\n\tconst segments = splitPath(path);\n\n\t// traverse down the tree\n\tfor (const property of segments) {\n\t\tif (!dataNode[property]) {\n\t\t\tconsole.warn(\n\t\t\t\t`can't remove listener from a non-existent path '${fullPath}'`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tdataNode = dataNode[property];\n\t}\n\n\tremoveById(dataNode[ND].listeners.shallow, id);\n\tremoveById(dataNode[ND].listeners.deep, id);\n};\n\nexport const removeAllListeners: RemoveAllListenersFunction =\n\tfunction removeAllListeners(this: PseudoThis, path = \"\") {\n\t\tconst fullPath = `${this.dataNode[ND].path}${path}`;\n\t\tconst segments = splitPath(path);\n\t\tlet dataNode = this.dataNode;\n\n\t\t//traverse down the tree\n\t\tfor (const property of segments) {\n\t\t\tif (!dataNode[property]) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`can't remove all listeners from a non-existent path '${fullPath}'`\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdataNode = dataNode[property];\n\t\t}\n\n\t\tdataNode[ND].listeners.shallow = [] as ListenerData[];\n\t\tdataNode[ND].listeners.deep = [] as ListenerData[];\n\t};\n\nexport const getOriginalTarget: GetOriginalTargetFunction =\n\tfunction getOriginalTarget(this: PseudoThis) {\n\t\treturn this.proxyNode[ND].target;\n\t};\n\nexport const getProxserveName: GetProxserveNameFunction =\n\tfunction getProxserveName(this: PseudoThis) {\n\t\treturn this.dataNode[NID].name;\n\t};\n\nexport const whoami: WhoAMI = function whoami(this: PseudoThis) {\n\treturn this.dataNode[NID].name + this.dataNode[ND].path;\n};\n\nexport const getProxserveNodes: GetProxserveNodesFunction =\n\tfunction getProxserveNodes(this: PseudoThis) {\n\t\treturn { dataNode: this.dataNode, proxyNode: this.proxyNode };\n\t};\n","/**\n * 2024 Native Signals <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\n\nimport { proxyTypes, ND, NID, EVENTS } from \"./globals\";\nimport type {\n\tTargetVariable,\n\tListenerData,\n\tChangeEvent,\n} from \"./types/globals\";\nimport type {\n\tDataNode,\n\tProxyNode,\n\tProxserveInstanceMetadata,\n\tPseudoThis,\n} from \"./types/proxserve-class\";\nimport { realtypeof } from \"./general-functions\";\nimport { whoami } from \"./pseudo-methods\";\n\n/**\n * Convert property name to valid path segment\n */\nexport function property2path(obj: any, property: string | number): string {\n\tif (typeof property === \"symbol\") {\n\t\tthrow new Error(`property of type \"symbol\" isn't path'able`);\n\t}\n\n\tconst typeofobj = realtypeof(obj);\n\tswitch (typeofobj) {\n\t\tcase \"Object\": {\n\t\t\treturn `.${property}`;\n\t\t}\n\t\tcase \"Array\": {\n\t\t\treturn `[${property}]`;\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.warn(`Not Implemented (type of '${typeofobj}')`);\n\t\t\treturn property as string;\n\t\t}\n\t}\n}\n\n/**\n * recursively switch between all proxies to their original targets.\n * note: original targets should never hold proxies under them,\n * thus altering the object references (getting from 'value') should be ok.\n * if whoever uses this library decides to\n * \t1. create a proxy with children (sub-proxies)\n * \t2. create a regular object\n * \t3. adding sub-proxies to the regular object\n * \t4. attaching the regular object to the proxy\n * then this regular object will be altered.\n */\nexport function unproxify(value: any): any {\n\tconst typeofvalue = realtypeof(value);\n\n\tif (proxyTypes[typeofvalue]) {\n\t\tlet target = value;\n\t\ttry {\n\t\t\ttarget = value.$getOriginalTarget();\n\t\t} catch (error) {}\n\n\t\tswitch (typeofvalue) {\n\t\t\tcase \"Object\": {\n\t\t\t\tconst keys = Object.keys(target);\n\t\t\t\tfor (const key of keys) {\n\t\t\t\t\ttarget[key] = unproxify(target[key]); // maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Array\": {\n\t\t\t\tfor (let i = 0; i < target.length; i++) {\n\t\t\t\t\ttarget[i] = unproxify(target[i]); // maybe alters target and maybe returning the exact same object\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconsole.warn(`Not Implemented (type of '${typeofvalue}')`);\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\treturn value; // primitive\n}\n\n/**\n * create or reset a node in a tree of meta-data (mainly path related)\n * and optionally create a node in a tree of proxy data (mainly objects related)\n */\nexport function createNodes(\n\tparentDataNode: DataNode,\n\tproperty: string | number,\n\tparentProxyNode?: ProxyNode,\n\ttarget?: TargetVariable\n): { dataNode: DataNode; proxyNode: ProxyNode | undefined } {\n\t//handle property path\n\tlet propertyPath: string;\n\tif (parentProxyNode?.[ND].target) {\n\t\tpropertyPath = property2path(parentProxyNode[ND].target, property);\n\t} else {\n\t\tpropertyPath = property2path({}, property); // if parent doesn't have target then treat it as object\n\t}\n\n\t//handle data node\n\tlet dataNode: DataNode = parentDataNode[property]; // try to receive existing data-node\n\tif (!dataNode) {\n\t\tdataNode = {\n\t\t\t[NID]: Object.create(parentDataNode[NID]),\n\t\t\t[ND]: {\n\t\t\t\tparentNode: parentDataNode,\n\t\t\t\tlisteners: {\n\t\t\t\t\tshallow: [] as ListenerData[],\n\t\t\t\t\tdeep: [] as ListenerData[],\n\t\t\t\t},\n\t\t\t},\n\t\t} as DataNode;\n\t\tparentDataNode[property] = dataNode;\n\t}\n\n\tdelete dataNode[NID].status; // clears old status in case a node previously existed\n\t// updates path (for rare case where parent was array and then changed to object or vice versa)\n\tif (!parentDataNode[ND].isTreePrototype) {\n\t\tObject.assign(dataNode[ND], {\n\t\t\tpath: parentDataNode[ND].path + propertyPath,\n\t\t\tpropertyPath,\n\t\t});\n\t} else {\n\t\tObject.assign(dataNode[ND], {\n\t\t\tpath: \"\",\n\t\t\tpropertyPath: \"\",\n\t\t});\n\t}\n\n\t// handle proxy node\n\tlet proxyNode: ProxyNode | undefined;\n\tif (parentProxyNode) {\n\t\tproxyNode = {\n\t\t\t[NID]: Object.create(parentProxyNode[NID]),\n\t\t\t[ND]: {\n\t\t\t\ttarget: target as TargetVariable,\n\t\t\t\tdataNode,\n\t\t\t},\n\t\t};\n\n\t\tparentProxyNode[property] = proxyNode;\n\n\t\t// attach nodes to each other\n\t\tdataNode[ND].proxyNode = proxyNode;\n\t} else {\n\t\t// this scenario is dangerous and exists only for `on()` of future variables (paths) that don't yet exist\n\t\tproxyNode = undefined;\n\t}\n\n\treturn { dataNode, proxyNode };\n}\n\nlet noStackFlag = false;\nexport function stackTraceLog(\n\tdataNode: DataNode,\n\tchange: ChangeEvent,\n\tlogLevel?: ProxserveInstanceMetadata[\"trace\"]\n) {\n\tif (logLevel !== \"normal\" && logLevel !== \"verbose\") {\n\t\treturn;\n\t}\n\n\tconst err = new Error();\n\tconst stack = err.stack;\n\n\tif (!stack) {\n\t\tif (!noStackFlag) {\n\t\t\t// log this only once. no need to spam.\n\t\t\tconsole.error(\n\t\t\t\t\"Can't log stack trace of proxserve. browser/runtime doesn't support Error.stack\"\n\t\t\t);\n\t\t\tnoStackFlag = true;\n\t\t}\n\t\treturn;\n\t}\n\n\t// break stack to individual lines. each line will point to a file and function.\n\tconst functionsTrace = stack.split(\"\\n\").map((value) => {\n\t\treturn value.trim();\n\t});\n\t// remove first and useless Error line.\n\tif (functionsTrace[0].toLowerCase().indexOf(\"error\") === 0) {\n\t\tfunctionsTrace.shift();\n\t}\n\t// delete this function's own line.\n\tfunctionsTrace.shift();\n\t// delete `initEmitEvent` line - overwrite it with a title.\n\tfunctionsTrace[0] = \"Stack Trace:\";\n\n\t// log the message header.\n\tconst pathname = whoami.call({ dataNode } as PseudoThis) + change.path;\n\tlet verb = change.type;\n\tif (change.type === EVENTS.shift || change.type === EVENTS.unshift) {\n\t\tverb += \"ed\";\n\t} else {\n\t\tverb += \"d\";\n\t}\n\n\tconsole.log(\n\t\t\"%c                                                                \",\n\t\t\"border-bottom: 1px solid #008;\"\n\t);\n\tconsole.log(\n\t\t`%c${pathname} %chas been ${verb}:`,\n\t\t\"font-weight: bold; color: #008;\",\n\t\t\"color: #000;\"\n\t);\n\n\t// verbose message with assigned values\n\tif (logLevel === \"verbose\") {\n\t\tif (change.type === \"splice\" || change.type === \"unshift\") {\n\t\t\tconsole.log(\n\t\t\t\t`%cArguments of ${change.type}:`,\n\t\t\t\t\"color: #555; font-style: italic;\"\n\t\t\t);\n\t\t\tconsole.log(change.args);\n\t\t}\n\n\t\tconsole.log(\"%cOld value was:\", \"color: #555; font-style: italic;\");\n\t\tconsole.log(change.oldValue);\n\t\tconsole.log(\"%cNew value is:\", \"color: #555; font-style: italic;\");\n\t\tconsole.log(change.value);\n\t}\n\n\t// the files and lines list message\n\tconsole.log(`%c${functionsTrace.join(\"\\n\")}`, \"color: #999;\");\n\tconsole.log(\n\t\t\"%c                                                                \",\n\t\t\"border-top: 1px solid #008;\"\n\t);\n}\n","export const DONT_PROXIFY_PREFIX = '_$';\nexport const PSEUDO_METHODS_ALTERNATIVE_NAMING_PREFIX = '$';","/**\n * 2024 Native Signals <noamlin@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n */\nimport { proxyTypes, NODE_STATUSES, PROXY_STATUSES, ND, NID } from \"./globals\";\nimport type { TargetVariable } from \"./types/globals\";\nimport type {\n\tProxserveInstance,\n\tProxserveInstanceAlternatives,\n\tDataNode,\n\tProxyNode,\n\tProxserveInstanceMetadata,\n} from \"./types/proxserve-class\";\nimport { unproxify, createNodes } from \"./supporting-functions\";\nimport * as pseudoMethods from \"./pseudo-methods\";\nimport * as proxyMethods from \"./proxy-methods\";\nimport { realtypeof, splitPath, evalPath } from \"./general-functions\";\nimport { initEmitEvent } from \"./event-emitter\";\nimport {\n\tDONT_PROXIFY_PREFIX,\n\tPSEUDO_METHODS_ALTERNATIVE_NAMING_PREFIX,\n} from \"./constants\";\n\n/**\n * save an array of all reserved function names\n * and also add synonyms to these functions\n */\nconst pseudoMethodsNames = Object.keys(pseudoMethods);\nconst pseudoMethodsExtended: Record<string | symbol, any> = {};\nfor (let i = pseudoMethodsNames.length - 1; i >= 0; i--) {\n\tconst name = pseudoMethodsNames[i];\n\tconst synonym = PSEUDO_METHODS_ALTERNATIVE_NAMING_PREFIX + name;\n\n\tpseudoMethodsNames.push(synonym);\n\tpseudoMethodsExtended[name] = pseudoMethods[name];\n\tpseudoMethodsExtended[synonym] = pseudoMethods[name];\n}\n\ninterface MakeOptions {\n\tstrict?: ProxserveInstanceMetadata[\"strict\"];\n\tmethodsEmitRaw?: ProxserveInstanceMetadata[\"methodsEmitRaw\"];\n\t/** internal root name of the instance */\n\tname?: string;\n\tdebug?: {\n\t\tdestroyDelay?: ProxserveInstanceMetadata[\"destroyDelay\"];\n\t\ttrace?: ProxserveInstanceMetadata[\"trace\"];\n\t};\n}\n\n/**\n * create a new proxy and a new node for a property of the parent's target-object\n */\nfunction createProxy<T>(\n\tmetadata: ProxserveInstanceMetadata,\n\tparentDataNode: DataNode,\n\ttargetProperty?: string\n): ProxserveInstance & T {\n\tconst parentProxyNode = parentDataNode[ND].proxyNode!;\n\tlet dataNode: DataNode;\n\tlet proxyNode: ProxyNode;\n\n\tif (targetProperty === undefined) {\n\t\t//refering to own node and not a child property (meaning root object)\n\t\tdataNode = parentDataNode;\n\t\tproxyNode = parentProxyNode;\n\t} else {\n\t\t//create new or reset an existing data-node and then creates a new proxy-node\n\t\tconst newNodes = createNodes(\n\t\t\tparentDataNode,\n\t\t\ttargetProperty,\n\t\t\tparentProxyNode,\n\t\t\tparentProxyNode[ND].target[targetProperty]\n\t\t);\n\t\tdataNode = newNodes.dataNode;\n\t\tproxyNode = newNodes.proxyNode!;\n\t}\n\n\tconst target = proxyNode[ND].target;\n\n\tconst typeoftarget = realtypeof(target);\n\n\tif (proxyTypes[typeoftarget]) {\n\t\tconst revocable = Proxy.revocable<TargetVariable>(target, {\n\t\t\tget: (\n\t\t\t\ttarget: TargetVariable /*same as parent scope 'target'*/,\n\t\t\t\tproperty: string | symbol,\n\t\t\t\tproxy\n\t\t\t) => {\n\t\t\t\tif (\n\t\t\t\t\tmetadata.methodsEmitRaw === false &&\n\t\t\t\t\tObject.prototype.hasOwnProperty.call(\n\t\t\t\t\t\tproxyMethods,\n\t\t\t\t\t\tproperty\n\t\t\t\t\t) &&\n\t\t\t\t\tproperty in Object.getPrototypeOf(target)\n\t\t\t\t) {\n\t\t\t\t\t// use a proxy method instead of the built-in method that is on the prototype chain\n\t\t\t\t\treturn proxyMethods[property].bind({\n\t\t\t\t\t\tmetadata,\n\t\t\t\t\t\tdataNode,\n\t\t\t\t\t\tproxyNode,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tpseudoMethodsNames.includes(property as string) &&\n\t\t\t\t\ttypeof target[property] === \"undefined\"\n\t\t\t\t) {\n\t\t\t\t\t// can access a pseudo function (or its synonym) if their keywords isn't used\n\t\t\t\t\treturn pseudoMethodsExtended[property].bind({\n\t\t\t\t\t\tmetadata,\n\t\t\t\t\t\tdataNode,\n\t\t\t\t\t\tproxyNode,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!target.propertyIsEnumerable(property) ||\n\t\t\t\t\ttypeof property === \"symbol\"\n\t\t\t\t) {\n\t\t\t\t\treturn target[property]; // non-enumerable or non-path'able aren't proxied\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t// biome-ignore lint/complexity/useOptionalChain: <explanation>\n\t\t\t\t\tproxyNode[property] && // there's a child node\n\t\t\t\t\tproxyNode[property][ND].proxy && // it holds a proxy\n\t\t\t\t\tproxyNode[property][NID].status === PROXY_STATUSES.alive\n\t\t\t\t) {\n\t\t\t\t\treturn proxyNode[property][ND].proxy;\n\t\t\t\t}\n\n\t\t\t\treturn target[property];\n\t\t\t},\n\n\t\t\tset: (\n\t\t\t\ttarget /*same as parent scope 'target'*/,\n\t\t\t\tproperty,\n\t\t\t\tvalue,\n\t\t\t\tproxy\n\t\t\t) => {\n\t\t\t\t//'receiver' is proxy\n\t\t\t\t/**\n\t\t\t\t * property can be a regular object because of a few possible reasons:\n\t\t\t\t * 1. proxy is deleted from tree but user keeps accessing it then it means he saved a reference.\n\t\t\t\t * 2. it is a non-enumerable property which means it was intentionally hidden.\n\t\t\t\t * 3. property is a symbol and symbols can't be proxied because we can't create a normal path for them.\n\t\t\t\t *    these properties are not proxied and should not emit change-event.\n\t\t\t\t *    except for: length\n\t\t\t\t * 4. property is manually set as raw object with the special prefix.\n\t\t\t\t * TODO: make a list of all possible properties exceptions (maybe function 'name'?)\n\t\t\t\t */\n\t\t\t\tif (dataNode[NID].status === NODE_STATUSES.blocked) {\n\t\t\t\t\t//blocked from changing values\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\"object is blocked. can't change value of property:\",\n\t\t\t\t\t\tproperty\n\t\t\t\t\t);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\ttypeof property === \"symbol\" ||\n\t\t\t\t\tproperty.startsWith(DONT_PROXIFY_PREFIX)\n\t\t\t\t) {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tproperty !== \"length\" &&\n\t\t\t\t\t!target.propertyIsEnumerable(property)\n\t\t\t\t) {\n\t\t\t\t\t//if setting a whole new property then it is non-enumerable (yet) so a further test is needed\n\t\t\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tproperty\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof descriptor === \"object\" &&\n\t\t\t\t\t\tdescriptor.enumerable === false\n\t\t\t\t\t) {\n\t\t\t\t\t\t//property was previously set\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst oldValue = target[property]; // should not be proxy\n\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\tif (\n\t\t\t\t\tproxyNode[property] !== undefined &&\n\t\t\t\t\tproxyNode[property][ND].proxy !== undefined\n\t\t\t\t) {\n\t\t\t\t\t// about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\tproxyNode[property][NID].status = PROXY_STATUSES.deleted;\n\t\t\t\t\tdelete dataNode[property][ND].proxyNode; // detach reference from data-node to proxy-node\n\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\tif (metadata.strict) {\n\t\t\t\t\t\t// postpone this cpu intense function for later, probably when proxserve is not in use\n\t\t\t\t\t\tsetTimeout(\n\t\t\t\t\t\t\tdestroy,\n\t\t\t\t\t\t\tmetadata.destroyDelay,\n\t\t\t\t\t\t\tproxyNode[property][ND].proxy\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst rawValue = unproxify(value);\n\t\t\t\ttarget[property] = rawValue; //assign new value\n\n\t\t\t\tlet isValueProxy = false;\n\t\t\t\tconst typeofvalue = realtypeof(rawValue);\n\t\t\t\tif (proxyTypes[typeofvalue]) {\n\t\t\t\t\tcreateProxy(metadata, dataNode, property); // if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\tisValueProxy = true;\n\t\t\t\t}\n\n\t\t\t\tinitEmitEvent(\n\t\t\t\t\tdataNode,\n\t\t\t\t\tproperty,\n\t\t\t\t\toldValue,\n\t\t\t\t\tisOldValueProxy,\n\t\t\t\t\trawValue,\n\t\t\t\t\tisValueProxy,\n\t\t\t\t\tmetadata.trace\n\t\t\t\t);\n\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * TODO: this function is incomplete and doesn't handle all of 'descriptor' scenarios\n\t\t\t */\n\t\t\tdefineProperty: (\n\t\t\t\ttarget /*same as parent scope 'target'*/,\n\t\t\t\tproperty,\n\t\t\t\tdescriptor\n\t\t\t) => {\n\t\t\t\tif (typeof property === \"symbol\") {\n\t\t\t\t\tObject.defineProperty(target, property, descriptor);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tconst oldValue = target[property]; //should not be proxy\n\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\tif (\n\t\t\t\t\tproxyNode[property] !== undefined &&\n\t\t\t\t\tproxyNode[property][ND].proxy !== undefined\n\t\t\t\t) {\n\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\tproxyNode[property][NID].status = PROXY_STATUSES.deleted;\n\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\tif (metadata.strict) {\n\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\tsetTimeout(\n\t\t\t\t\t\t\tdestroy,\n\t\t\t\t\t\t\tmetadata.destroyDelay,\n\t\t\t\t\t\t\tproxyNode[property][ND].proxy\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdescriptor.value = unproxify(descriptor.value);\n\t\t\t\tObject.defineProperty(target, property, descriptor); //defining the new value\n\t\t\t\tconst value = descriptor.value;\n\t\t\t\tlet isValueProxy = false;\n\t\t\t\t//excluding non-enumerable properties from being proxied\n\t\t\t\tconst typeofvalue = realtypeof(descriptor.value);\n\t\t\t\tif (proxyTypes[typeofvalue] && descriptor.enumerable === true) {\n\t\t\t\t\tcreateProxy(metadata, dataNode, property); //if trying to add a new value which is an object then make it a proxy\n\t\t\t\t\tisValueProxy = true;\n\t\t\t\t}\n\n\t\t\t\tinitEmitEvent(\n\t\t\t\t\tdataNode,\n\t\t\t\t\tproperty,\n\t\t\t\t\toldValue,\n\t\t\t\t\tisOldValueProxy,\n\t\t\t\t\tvalue,\n\t\t\t\t\tisValueProxy,\n\t\t\t\t\tmetadata.trace\n\t\t\t\t);\n\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\tdeleteProperty: (\n\t\t\t\ttarget /*same as parent scope 'target'*/,\n\t\t\t\tproperty\n\t\t\t) => {\n\t\t\t\tif (\n\t\t\t\t\t!target.propertyIsEnumerable(property) ||\n\t\t\t\t\ttypeof property === \"symbol\"\n\t\t\t\t) {\n\t\t\t\t\t//non-proxied properties simply get deleted and nothing more\n\t\t\t\t\tdelete target[property];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (dataNode[NID].status === NODE_STATUSES.blocked) {\n\t\t\t\t\t//blocked from changing values\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`can't delete property '${property}'. object is blocked.`\n\t\t\t\t\t);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (property in target) {\n\t\t\t\t\tconst oldValue = target[property]; //should not be proxy\n\t\t\t\t\tlet isOldValueProxy = false;\n\t\t\t\t\tif (\n\t\t\t\t\t\tproxyNode[property] !== undefined &&\n\t\t\t\t\t\tproxyNode[property][ND].proxy !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\t//about to overwrite an existing property which is a proxy (about to detach a proxy)\n\t\t\t\t\t\tproxyNode[property][NID].status =\n\t\t\t\t\t\t\tPROXY_STATUSES.deleted;\n\t\t\t\t\t\tdelete dataNode[property][ND].proxyNode; //detach reference from data-node to proxy-node\n\t\t\t\t\t\tisOldValueProxy = true;\n\t\t\t\t\t\tif (metadata.strict) {\n\t\t\t\t\t\t\t//postpone this cpu intense function for later, probably when proxserve is not is use\n\t\t\t\t\t\t\tsetTimeout(\n\t\t\t\t\t\t\t\tdestroy,\n\t\t\t\t\t\t\t\tmetadata.destroyDelay,\n\t\t\t\t\t\t\t\tproxyNode[property][ND].proxy\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete target[property]; // actual delete\n\n\t\t\t\t\tinitEmitEvent(\n\t\t\t\t\t\tdataNode,\n\t\t\t\t\t\tproperty,\n\t\t\t\t\t\toldValue,\n\t\t\t\t\t\tisOldValueProxy,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tmetadata.trace\n\t\t\t\t\t);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn true; //do nothing because there's nothing to delete\n\t\t\t},\n\t\t} as ProxyHandler<TargetVariable>) as {\n\t\t\tproxy: ProxserveInstance & T;\n\t\t\trevoke: () => void;\n\t\t};\n\n\t\tproxyNode[ND].proxy = revocable.proxy;\n\t\tproxyNode[ND].revoke = revocable.revoke;\n\n\t\tif (proxyTypes[typeoftarget]) {\n\t\t\tconst keys = Object.keys(target); //handles both Objects and Arrays\n\t\t\tfor (const key of keys) {\n\t\t\t\tif (key.startsWith(DONT_PROXIFY_PREFIX)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst typeofproperty = realtypeof(target[key]);\n\t\t\t\tif (proxyTypes[typeofproperty]) {\n\t\t\t\t\tcreateProxy(metadata, dataNode, key); //recursively make child objects also proxies\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn(`Type of \"${typeoftarget}\" is not implemented`);\n\t\t}\n\n\t\treturn revocable.proxy;\n\t}\n\n\tconst types = Object.keys(proxyTypes);\n\tthrow new Error(`Must observe an ${types.join(\"/\")}`);\n}\n\n/**\n * make a new proxserve instance\n */\nfunction make<T>(\n\ttarget: TargetVariable,\n\toptions = {} as MakeOptions\n): ProxserveInstance & T {\n\tconst { strict = true, methodsEmitRaw = false, name = \"\", debug } = options;\n\n\tconst destroyDelay = debug?.destroyDelay ?? 1000;\n\tconst trace = debug?.trace ?? \"none\";\n\n\tconst dataTreePrototype: DataNode = {\n\t\t[NID]: {\n\t\t\tstatus: NODE_STATUSES.active,\n\t\t\tname,\n\t\t},\n\t\t[ND]: { isTreePrototype: true } as DataNode[typeof ND],\n\t};\n\tconst proxyTreePrototype: ProxyNode = {\n\t\t[NID]: { status: PROXY_STATUSES.alive },\n\t\t[ND]: { isTreePrototype: true } as ProxyNode[typeof ND],\n\t};\n\n\tconst newNodes = createNodes(\n\t\tdataTreePrototype,\n\t\t\"\",\n\t\tproxyTreePrototype,\n\t\ttarget\n\t);\n\n\tconst metadata = {\n\t\tstrict,\n\t\tmethodsEmitRaw,\n\t\tdestroyDelay,\n\t\ttrace,\n\t\tdataTree: newNodes.dataNode,\n\t\tproxyTree: newNodes.proxyNode,\n\t} as ProxserveInstanceMetadata;\n\n\treturn createProxy<T>(metadata, metadata.dataTree);\n}\n\n/**\n * Recursively revoke proxies, allowing them to be garbage collected.\n * note: when this function is auto-called it should be called with a 1000 milliseconds\n * delay to let time for all events to finish.\n */\nfunction destroy(proxy: ProxserveInstance) {\n\tlet proxyNode: ProxyNode;\n\ttry {\n\t\tconst nodes = (\n\t\t\tproxy as ProxserveInstanceAlternatives\n\t\t).$getProxserveNodes();\n\t\tproxyNode = nodes.proxyNode;\n\t} catch (error) {\n\t\treturn; // proxy variable isn't a proxy\n\t}\n\n\tif (proxyNode[NID].status === PROXY_STATUSES.alive) {\n\t\tproxyNode[NID].status = PROXY_STATUSES.deleted;\n\t}\n\n\tconst typeofproxy = realtypeof(proxy);\n\n\tif (proxyTypes[typeofproxy]) {\n\t\tconst keys = Object.keys(proxy); // handles both Objects and Arrays\n\t\tfor (const key of keys) {\n\t\t\tif (key.startsWith(DONT_PROXIFY_PREFIX)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst typeofproperty = realtypeof(proxy[key]);\n\t\t\t\tif (proxyTypes[typeofproperty]) {\n\t\t\t\t\t// going to proxy[key], which is deleted, will return the original target so we will bypass it\n\t\t\t\t\tdestroy(proxyNode[key][ND].proxy!);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error); // don't throw and kill the whole process just if this iteration fails\n\t\t\t}\n\t\t}\n\n\t\tproxyNode[ND].revoke?.();\n\t\t//proxyNode[ND].proxy = undefined;\n\t\tproxyNode[NID].status = PROXY_STATUSES.revoked;\n\t} else {\n\t\tconsole.warn(`Type of \"${typeofproxy}\" is not implemented`);\n\t}\n}\n\n// for importing this type from the main generated d.ts\nexport type { ProxserveInstance };\n"],"names":[],"mappings":"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"}